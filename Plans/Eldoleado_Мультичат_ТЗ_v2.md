# Техническое задание: Мультиконтекстный диалоговый движок Eldoleado

## 1. Суть проблемы

Стандартные чат-боты работают линейно: один вопрос — один ответ — следующий вопрос. Но реальные клиенты так не общаются.

Клиент приходит и говорит: "У меня iPhone 12, батарея вздулась. А ещё у сына тоже iPhone 12, но там экран разбит. И жена просила узнать про свой Samsung — у него разъём зарядки барахлит..."

Он прыгает с одного на другое, путается, уточняет, возвращается к тому, что уже говорил. А потом через два дня пишет: "Занесу завтра телефон сына. А свой пока не буду."

Проблемы, которые не решает ни один существующий чат-бот:
- Как понять, какой из двух одинаковых iPhone 12 имеется в виду?
- Как не перепутать устройство клиента с устройством его сына?
- Как создать отдельные заявки и связать их с правильными устройствами?
- Как вспомнить контекст через два дня?
- Как переключаться между темами в рамках одного диалога?

Это касается не только ремонта телефонов. Обувная мастерская, салон красоты, репетитор, садовник — везде одно и то же.

---

## 2. Ключевые идеи

### 2.1. Граф — это и есть контекст

Не нужно отдельно хранить "состояние диалога", "текущую тему", "активную заявку". Всё это уже лежит в связях между сообщениями и сущностями в графовой базе данных.

Контекст не хранится — он вычисляется из графа в момент запроса.

### 2.2. Сообщение = Точка касания = Узел графа

**Ключевой инсайт:** не нужно разделять «граф диалога» и «граф обогащения профиля». Это единый граф.

Каждое взаимодействие с клиентом — будь то:
- Сообщение в WhatsApp
- Звонок
- Визит в точку
- Показ ретаргетинга
- Email

...это узел в едином графе. Всё это — точки касания, и все они живут в одной структуре данных.

### 2.3. Единый граф с уровнями видимости

Граф един, но имеет два уровня доступа:

| Уровень | Что видит | Зачем |
|---------|-----------|-------|
| **Вертикаль** | Только свой срез графа | Мастер работает со своими клиентами |
| **Ядро** | Весь граф, все связи | Аналитика, ML, кросс-вертикальные инсайты |

**Вертикаль не видит:**
- Что клиент ходит в другие бизнесы на платформе
- Связи между вертикалями
- Данные других вертикалей

**Ядро видит всё:**
- Один клиент → 3 разных бизнеса
- Паттерны поведения между вертикалями
- Глобальную картину для обучения AI

---

## 3. Архитектура: два слоя данных

### 3.1. Графовая база (Neo4j) — связи и контекст

Хранит только то, что нужно для идентификации и навигации:
- Узлы: Клиент, Устройство, Поломка, Точка касания (бывш. Сообщение)
- Рёбра: связи между ними

Граф отвечает на вопросы:
- Кто с кем связан?
- О чём говорили?
- Какие устройства у этого клиента?
- Когда последний раз упоминали это устройство?
- Через какие каналы касались клиента?

### 3.2. SQL база (Supabase) — детальные данные

Хранит всё "тяжёлое" и детальное:
- Данные клиента: телефон, WhatsApp, Telegram, email, fingerprint
- Данные устройства: IMEI, серийный номер, фото, состояние
- Данные поломки: цена, запчасти, статус ремонта, гарантия
- Данные точек касания: полный текст, канал, raw payload, медиа

### 3.3. Принцип разделения

Граф лёгкий, быстрый, отвечает на "кто-что-когда-с кем-через-какой-канал".
SQL отвечает на "расскажи подробности".

Связь между базами — по общему UUID на каждую сущность.

---

## 4. Структура графа

### 4.1. Узлы (вершины)

**Клиент (Client)**
- id (UUID, общий с SQL)
- минимум данных для идентификации

**Устройство (Device)**
- id (UUID)
- owner_label — чьё устройство ("свой", "сына", "жены")

**Поломка (Problem)**
- id (UUID)
- type — тип поломки ("display", "battery", "charging")

**Точка касания (Touchpoint)** ← расширено от "Сообщение"
- id (UUID)
- timestamp — когда произошло
- type — тип касания (message, call, visit, retargeting, email)
- channel — канал (whatsapp, telegram, phone, in_person, vk_ads, email)
- direction — направление (inbound, outbound)

**Вертикаль (Vertical)**
- id (UUID)
- type — тип вертикали (phone_repair, beauty, auto_service...)

**Канал связи (Channel)**
- id (UUID)
- type — тип канала (whatsapp, telegram, vk, email, phone, fingerprint)

### 4.2. Рёбра (связи)

**Между клиентами:**
- RELATIVE — родственная связь (папа-сын, муж-жена)
- REFERRED — реферальная связь (кто кого привёл)

**Клиент → Устройство:**
- OWNS — владеет устройством

**Клиент → Канал:**
- HAS_CHANNEL — у клиента есть этот канал связи

**Клиент → Вертикаль:**
- CUSTOMER_OF — является клиентом этой вертикали

**Устройство → Поломка:**
- HAS_PROBLEM — у устройства есть поломка

**Точка касания — связи со всем:**
- FROM — от какого клиента (или TO — к какому клиенту для исходящих)
- ABOUT_DEVICE — про какое устройство
- ABOUT_PROBLEM — про какую поломку
- REFERS_TO — ссылается на другую точку касания
- VIA_CHANNEL — через какой канал
- IN_VERTICAL — в рамках какой вертикали

### 4.3. Точка касания как универсальный "якорь"

Ключевая идея: каждая точка касания — это узел, от которого расходятся рёбра ко всему, что в нём упомянуто или задействовано.

Точка касания может быть связана одновременно:
- С клиентом (кто инициировал / кому адресовано)
- С устройством (про что)
- С поломкой (какая проблема)
- С другой точкой касания (на что ссылается)
- С каналом (через что)
- С вертикалью (в рамках какого бизнеса)

Цепочка точек касания с их рёбрами — это и есть история контекста и обогащения профиля.

---

## 5. Уровни видимости графа

### 5.1. Архитектура доступа

```
┌─────────────────────────────────────────────────────────────────┐
│                         ЯДРО ELDOLEADO                          │
│                                                                 │
│   Видит ВСЁ: все вертикали, все связи между клиентами,         │
│   кросс-вертикальные паттерны, глобальную аналитику            │
│                                                                 │
│  ┌───────────────┐  ┌───────────────┐  ┌───────────────┐       │
│  │  Вертикаль A  │  │  Вертикаль B  │  │  Вертикаль C  │       │
│  │               │  │               │  │               │       │
│  │ Видит только  │  │ Видит только  │  │ Видит только  │       │
│  │ свой срез     │  │ свой срез     │  │ свой срез     │       │
│  │               │  │               │  │               │       │
│  │ [Клиенты]     │  │ [Клиенты]     │  │ [Клиенты]     │       │
│  │ [Касания]     │  │ [Касания]     │  │ [Касания]     │       │
│  │ [Устройства]  │  │ [Устройства]  │  │ [Устройства]  │       │
│  └───────────────┘  └───────────────┘  └───────────────┘       │
│         │                  │                  │                 │
│         └──────────────────┼──────────────────┘                 │
│                            │                                    │
│               [Скрытые кросс-связи клиентов]                    │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 5.2. Что видит вертикаль (мастер/бизнес)

- Свои клиенты и их история в этой вертикали
- Свои точки касания (сообщения, звонки, визиты)
- Связи внутри своего контекста (клиент → устройства → заказы)
- Каналы связи клиента (для коммуникации)
- Социальные связи между своими клиентами (рефералы)

**Вертикаль НЕ видит:**
- Что клиент ходит в другие бизнесы
- Точки касания в других вертикалях
- Устройства/объекты из других вертикалей
- Общую активность клиента в экосистеме

### 5.3. Что видит ядро (Eldoleado)

Всё. Включая:
- Полный граф всех клиентов и их связей
- Все точки касания во всех вертикалях
- Кросс-вертикальные связи клиентов
- Паттерны поведения между нишами

### 5.4. Практическая ценность для ядра

**Качество скоринга:**
- Клиент активен в 3 вертикалях = ценнее для всех
- Можно предсказывать churn на основе активности в экосистеме

**Рекомендации вертикалям:**
- "Твои клиенты часто также клиенты pet-сервисов"
- "В твоей нише работает канал X лучше канала Y"

**Обучение AI:**
- Паттерны диалогов из одной ниши применимы в другой
- Общая база знаний по disambiguation

**Антифрод:**
- Видим подозрительную активность сквозь вертикали
- Один "клиент" создаёт проблемы в разных бизнесах

**Продуктовые решения:**
- Какие вертикали синергичны
- Где есть спрос на новые интеграции

### 5.5. Реализация уровней доступа

**Технически:** каждый запрос к графу фильтруется по vertical_id.

```cypher
// Запрос от вертикали — видит только своё
MATCH (c:Client)-[:CUSTOMER_OF]->(v:Vertical {id: $verticalId})
MATCH (t:Touchpoint)-[:IN_VERTICAL]->(v)
MATCH (t)-[:FROM|TO]->(c)
RETURN c, t

// Запрос от ядра — видит всё
MATCH (c:Client)
OPTIONAL MATCH (c)-[:CUSTOMER_OF]->(v:Vertical)
OPTIONAL MATCH (t:Touchpoint)-[:FROM|TO]->(c)
RETURN c, v, t
```

**Принцип:** данные хранятся один раз, фильтрация на уровне запросов.

---

## 6. Пример: один клиент в едином графе

Клиент Иван взаимодействует с тремя бизнесами на платформе:

```
[Иван] ─── WhatsApp сообщение ──────→ [Ремонт телефонов]
   │              │
   │              └── ABOUT_DEVICE ──→ [iPhone 12 свой]
   │
   ├───── Визит ────────────────────→ [Ремонт телефонов]
   │              │
   │              └── ABOUT_DEVICE ──→ [iPhone 12 сына]
   │
   ├───── WhatsApp сообщение ───────→ [Салон красоты]      ← вертикаль "Ремонт" не видит
   │              │
   │              └── ABOUT ─────────→ [Стрижка]
   │
   └───── Ретаргетинг показ ────────→ [Автосервис]         ← вертикаль "Ремонт" не видит
                  │
                  └── VIA_CHANNEL ──→ [VK Ads]
```

**Что видит "Ремонт телефонов":**
- Иван, его 2 iPhone, 2 точки касания (сообщение + визит)

**Что видит ядро:**
- Иван — активный пользователь платформы в 3 вертикалях
- Паттерн: клиенты ремонта часто ходят в салоны
- Ретаргетинг автосервиса работает на этот сегмент

---

## 7. Типы точек касания

### 7.1. Входящие (inbound)

| Тип | Канал | Что создаёт в графе |
|-----|-------|---------------------|
| Сообщение клиента | WhatsApp, Telegram, VK, Avito | Touchpoint + связи с сущностями |
| Звонок от клиента | Phone | Touchpoint + запись (в SQL) |
| Визит клиента | In Person | Touchpoint + история покупки |
| Заявка с сайта | Web Form | Touchpoint + fingerprint |
| Переход по ссылке | Web | Touchpoint + fingerprint + источник |

### 7.2. Исходящие (outbound)

| Тип | Канал | Что создаёт в графе |
|-----|-------|---------------------|
| Сообщение клиенту | WhatsApp, Telegram, SMS | Touchpoint (direction: outbound) |
| Звонок клиенту | Phone | Touchpoint + результат |
| Email | Email | Touchpoint + статус (открыт/клик) |
| Ретаргетинг | VK Ads, РСЯ | Touchpoint + показы |
| Push-уведомление | App | Touchpoint + статус |

### 7.3. Автоматические касания

Система сама создаёт точки касания по триггерам:
- "Не был 30 дней" → автокасание в WhatsApp
- "День рождения" → поздравление
- "6 мес после ремонта" → напоминание о профилактике

Эти касания также попадают в граф с типом `auto` и связью с триггером.

---

## 8. Как работает диалог

### 8.1. Обработка входящего сообщения

1. Клиент пишет сообщение (точка касания)
2. LLM парсит текст → извлекает сущности (устройство, поломка, владелец)
3. Запрос в граф: что мы знаем об этом клиенте, его устройствах, истории
4. Граф возвращает готовый контекст (с фильтром по вертикали)
5. Запрос в SQL за деталями (цены, статусы)
6. LLM получает готовый контекст и генерирует ответ
7. Создаётся новый узел Touchpoint в графе с рёбрами к упомянутым сущностям
8. Детали сохраняются в SQL

### 8.2. Что делает LLM

- Парсит текущее сообщение (текст → сущности)
- Генерирует ответ на основе готового контекста

### 8.3. Что НЕ делает LLM (делает граф)

- Не читает все предыдущие сообщения
- Не пытается понять связи между клиентами и устройствами
- Не угадывает контекст
- Не вспоминает, о чём говорили вчера или неделю назад

### 8.4. Преимущества

- Скорость: граф отвечает за миллисекунды
- Точность: контекст вычисляется, а не угадывается
- Экономия: меньше токенов в промпт
- Надёжность: граф не забывает и не путает

---

## 9. Логика уточнения (disambiguation)

### 9.1. Когда уточнять

Граф даёт информацию для принятия решения:
- Сколько похожих устройств у клиента
- Когда каждое упоминалось последний раз
- В каком контексте упоминалось

### 9.2. Правила уточнения

**Одно устройство** — всё понятно, не спрашивать.

**Несколько устройств:**
- Сегодня упоминали только одно → использовать его
- Сегодня не упоминали ни одно → спросить
- Сегодня упоминали несколько → спросить

### 9.3. Уровень уверенности

- Упоминали сегодня → уверены → не спрашиваем
- Упоминали вчера → почти уверены → мягко уточняем
- Упоминали давно → не уверены → явно спрашиваем

Пример мягкого уточнения: "Вы про iPhone 12 сына, верно?"
Вместо тупого: "Какой iPhone 12 вы имеете в виду?"

---

## 10. Переключение контекста

### 10.1. Автоматическое переключение

Клиент упомянул другое устройство → новая точка касания получает ребро к другому узлу → контекст переключился автоматически.

### 10.2. Возврат к предыдущей теме

Клиент говорит "а что там по первому телефону?" → бот идёт по рёбрам назад через REFERS_TO → находит контекст.

### 10.3. Параллельные темы

Не проблема. Каждая точка касания сама знает, к чему она относится. Несколько тем могут обсуждаться параллельно.

---

## 11. История и память

### 11.1. Краткосрочная память (в рамках диалога)

Цепочка точек касания с рёбрами. Бот видит, о чём говорили 5 минут назад.

### 11.2. Долгосрочная память (между диалогами)

Граф хранит всё. Клиент вернулся через месяц — бот делает запрос — видит всю историю:
- Все устройства клиента
- Все обращения по каждому устройству
- Кто ещё из семьи обращался
- Все каналы связи с клиентом
- Все точки касания (сообщения, звонки, визиты, ретаргетинг)

### 11.3. Идентификация устройств

Два одинаковых iPhone 12 различаются по:
- owner_label (свой / сына)
- истории обращений
- времени последнего упоминания

---

## 12. Универсальность (вертикали)

Структура одинаковая для любой вертикали, меняются только названия:

**Ремонт телефонов:**
- Устройство = телефон
- Поломка = проблема с телефоном

**Обувная мастерская:**
- Устройство = пара обуви
- Поломка = проблема с обувью

**Парикмахерская:**
- Устройство = человек (клиент или член семьи)
- Поломка = услуга (стрижка, окрашивание)

**Садовник:**
- Устройство = объект (дерево, газон, забор)
- Поломка = работа (обрезка, покраска)

В рамках одного диалога вертикаль всегда одна. Клиент общается с конкретным бизнесом. Но в графе ядра видны все его взаимодействия со всеми вертикалями.

---

## 13. Чего не существует на рынке

По результатам исследования: ни в мире, ни в России нет решения, которое объединяет:

1. Извлечение нескольких сущностей из хаотичного диалога
2. Различение одинаковых объектов ("мой iPhone 12" vs "iPhone 12 сына")
3. Граф отношений клиент → устройства → история обращений
4. Переключение между объектами в диалоге с уточнением у клиента
5. **Единый граф точек касания (сообщения + звонки + визиты + ретаргетинг)**
6. **Уровни видимости (вертикаль видит своё, ядро видит всё)**

Существующие решения:
- Либо линейные боты с кнопками
- Либо CRM с историей, но без интеллектуального диалога
- Либо NLU-платформы с контекстом, но без графа персональных объектов
- Либо CDP (Customer Data Platform), но без диалогового AI

**Это ноу-хау Eldoleado.**

---

## 14. Технологический стек

- **Графовая база:** Neo4j (self-hosted, Community Edition)
- **SQL база:** Supabase (PostgreSQL)
- **LLM:** Claude / GPT для парсинга и генерации ответов
- **Связь между базами:** общий UUID на каждую сущность
- **Уровни доступа:** фильтрация запросов по vertical_id

---

## 15. Следующие шаги

1. Детальное проектирование схемы графа (все типы узлов и рёбер)
2. Проектирование таблиц SQL
3. Алгоритм парсинга сообщений (извлечение сущностей)
4. Алгоритм disambiguation (когда и как уточнять)
5. Реализация уровней видимости (фильтрация по vertical_id)
6. Интеграция с мессенджерами
7. Интеграция с рекламными платформами (ретаргетинг как точки касания)
8. Интерфейс оператора (desktop и mobile)

---

*Документ создан: ноябрь 2024*
*Обновлён: ноябрь 2025 — добавлена концепция единого графа и уровней видимости*
*Проект: Eldoleado — AI-powered CRM для микробизнеса*