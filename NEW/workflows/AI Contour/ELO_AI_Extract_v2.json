{
  "name": "ELO_AI_Extract_v2",
  "description": "Four-level context extraction (global, domain, vertical, tenant)",
  "active": false,
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "elo-ai-extract-v2",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "webhook-1",
      "name": "Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [-480, 0],
      "webhookId": "elo-ai-extract-v2"
    },
    {
      "parameters": {
        "jsCode": "const input = $input.first().json.body || $input.first().json;\n\nif (!input.message) {\n  throw new Error('Missing required field: message');\n}\nif (!input.tenant_id) {\n  throw new Error('Missing required field: tenant_id');\n}\n\nreturn {\n  message: input.message,\n  tenant_id: input.tenant_id,\n  dialog_id: input.dialog_id || null,\n  context: input.context || {},\n  trace_id: input.trace_id || `trace_${Date.now()}`\n};"
      },
      "id": "validate-input",
      "name": "Validate Input",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [-256, 0]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT code, name, extraction_prompt, output_schema, normalization_ref\nFROM elo_context_types\nWHERE is_active = true\nORDER BY sort_order;",
        "options": {}
      },
      "id": "load-global-context",
      "name": "Load Global Context Types",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [0, -200],
      "credentials": {
        "postgres": {
          "id": "n2SyhP9QhMnp1ryk",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT dct.code, dct.name, dct.extraction_prompt, dct.output_schema, dct.normalization_ref, d.code as domain_code\nFROM elo_d_context_types dct\nJOIN elo_domains d ON d.id = dct.domain_id\nJOIN elo_t_tenant_domains ttd ON ttd.domain_id = d.id\nWHERE ttd.tenant_id = $1\n  AND ttd.is_active = true\n  AND dct.is_active = true\n  AND d.is_active = true\nORDER BY d.code, dct.sort_order;",
        "options": {
          "queryReplacement": "={{ [$('Validate Input').first().json.tenant_id] }}"
        }
      },
      "id": "load-domain-context",
      "name": "Load Domain Context Types",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [0, -50],
      "credentials": {
        "postgres": {
          "id": "n2SyhP9QhMnp1ryk",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT vct.code, vct.name, vct.extraction_prompt, vct.output_schema, vct.normalization_ref, v.code as vertical_code, d.code as domain_code\nFROM elo_v_context_types vct\nJOIN elo_verticals v ON v.id = vct.vertical_id\nJOIN elo_domains d ON d.id = v.domain_id\nJOIN elo_t_tenant_verticals ttv ON ttv.vertical_id = v.id\nWHERE ttv.tenant_id = $1\n  AND ttv.is_active = true\n  AND vct.is_active = true\n  AND v.is_active = true\nORDER BY d.code, v.code, vct.sort_order;",
        "options": {
          "queryReplacement": "={{ [$('Validate Input').first().json.tenant_id] }}"
        }
      },
      "id": "load-vertical-context",
      "name": "Load Vertical Context Types",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [0, 100],
      "credentials": {
        "postgres": {
          "id": "n2SyhP9QhMnp1ryk",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT tco.context_type_code, tco.level, tco.extraction_prompt_override, tco.output_schema_override, tco.is_disabled\nFROM elo_t_context_type_overrides tco\nWHERE tco.tenant_id = $1\n  AND tco.is_active = true;",
        "options": {
          "queryReplacement": "={{ [$('Validate Input').first().json.tenant_id] }}"
        }
      },
      "id": "load-tenant-overrides",
      "name": "Load Tenant Overrides",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [0, 250],
      "credentials": {
        "postgres": {
          "id": "n2SyhP9QhMnp1ryk",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT code, pattern, replacement, priority\nFROM elo_normalization_rules\nWHERE is_active = true\nORDER BY priority DESC;",
        "options": {}
      },
      "id": "load-normalization",
      "name": "Load Normalization Rules",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [0, 400],
      "credentials": {
        "postgres": {
          "id": "n2SyhP9QhMnp1ryk",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "mode": "combine",
        "combinationMode": "multiplex",
        "options": {}
      },
      "id": "merge-all",
      "name": "Merge All Data",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3,
      "position": [256, 100]
    },
    {
      "parameters": {
        "jsCode": "// Collect all loaded data\nconst inputData = $('Validate Input').first().json;\nconst globalTypes = $('Load Global Context Types').all().map(i => ({ ...i.json, level: 'global' }));\nconst domainTypes = $('Load Domain Context Types').all().map(i => ({ ...i.json, level: 'domain' }));\nconst verticalTypes = $('Load Vertical Context Types').all().map(i => ({ ...i.json, level: 'vertical' }));\nconst overrides = $('Load Tenant Overrides').all().map(i => i.json);\nconst normRules = $('Load Normalization Rules').all().map(i => i.json);\n\n// Build override map\nconst overrideMap = {};\nfor (const o of overrides) {\n  overrideMap[`${o.level}:${o.context_type_code}`] = o;\n}\n\n// Merge all context types with overrides\nconst allTypes = [];\n\nfunction applyOverride(ct, override) {\n  if (!override) return ct;\n  if (override.is_disabled) return null;\n  return {\n    ...ct,\n    extraction_prompt: override.extraction_prompt_override || ct.extraction_prompt,\n    output_schema: override.output_schema_override || ct.output_schema\n  };\n}\n\n// Process global types\nfor (const ct of globalTypes) {\n  const override = overrideMap[`global:${ct.code}`];\n  const merged = applyOverride(ct, override);\n  if (merged) allTypes.push(merged);\n}\n\n// Process domain types\nfor (const ct of domainTypes) {\n  const override = overrideMap[`domain:${ct.code}`];\n  const merged = applyOverride(ct, override);\n  if (merged) allTypes.push(merged);\n}\n\n// Process vertical types\nfor (const ct of verticalTypes) {\n  const override = overrideMap[`vertical:${ct.code}`];\n  const merged = applyOverride(ct, override);\n  if (merged) allTypes.push(merged);\n}\n\n// Build unified extraction prompt\nconst entityDescriptions = allTypes.map(ct => {\n  const schema = typeof ct.output_schema === 'string' ? JSON.parse(ct.output_schema) : ct.output_schema;\n  return `- ${ct.code}: ${ct.extraction_prompt || ct.name}\\n  Schema: ${JSON.stringify(schema)}`;\n}).join('\\n');\n\nconst systemPrompt = `You are a context extraction system.\\nExtract entities from user messages and return ONLY valid JSON.\\n\\nEntity types to extract:\\n${entityDescriptions}\\n\\nRULES:\\n1. Return ONLY JSON array, no explanations\\n2. Extract ALL mentioned entities\\n3. If entity unclear, extract what you can\\n4. Empty array [] if nothing to extract\\n5. Each extracted entity must have \"type\" field matching entity code`;\n\nconst userPrompt = `Extract entities from: \"${inputData.message}\"\\n\\nReturn JSON array:`;\n\nreturn {\n  message: inputData.message,\n  tenant_id: inputData.tenant_id,\n  dialog_id: inputData.dialog_id,\n  context: inputData.context,\n  trace_id: inputData.trace_id,\n  system_prompt: systemPrompt,\n  user_prompt: userPrompt,\n  context_types: allTypes,\n  normalization_rules: normRules,\n  _debug: {\n    global_count: globalTypes.length,\n    domain_count: domainTypes.length,\n    vertical_count: verticalTypes.length,\n    overrides_count: overrides.length\n  }\n};"
      },
      "id": "build-prompt",
      "name": "Build Unified Prompt",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [480, 100]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://openrouter.ai/api/v1/chat/completions",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "openRouterApi",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({\n  model: 'qwen/qwen3-30b-a3b:free',\n  messages: [\n    { role: 'system', content: $json.system_prompt },\n    { role: 'user', content: $json.user_prompt }\n  ],\n  temperature: 0.1,\n  max_tokens: 1000\n}) }}",
        "options": {
          "timeout": 60000
        }
      },
      "id": "call-llm",
      "name": "Call OpenRouter",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [704, 100],
      "credentials": {
        "openRouterApi": {
          "id": "ameOTCcGgTm3hbtM",
          "name": "OpenRouter account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "const response = $json;\nconst buildData = $('Build Unified Prompt').first().json;\nconst normRules = buildData.normalization_rules;\n\nlet entities = [];\nlet rawContent = '';\n\ntry {\n  rawContent = response.choices?.[0]?.message?.content || '[]';\n  \n  // Clean up response\n  rawContent = rawContent.trim();\n  \n  // Remove thinking tags if present (Qwen3)\n  rawContent = rawContent.replace(/<think>[\\s\\S]*?<\\/think>/g, '').trim();\n  \n  // Extract JSON from response\n  const jsonMatch = rawContent.match(/\\[[\\s\\S]*\\]/);\n  if (jsonMatch) {\n    rawContent = jsonMatch[0];\n  }\n  \n  entities = JSON.parse(rawContent);\n  \n  if (!Array.isArray(entities)) {\n    entities = [entities];\n  }\n  \n} catch (e) {\n  entities = [];\n}\n\n// Apply normalization rules\nfunction normalize(value, fieldType) {\n  if (!value || typeof value !== 'string') return value;\n  \n  const applicableRules = normRules.filter(r => r.code === fieldType || r.code === 'all');\n  \n  for (const rule of applicableRules) {\n    try {\n      const pattern = new RegExp(rule.pattern, 'gi');\n      if (pattern.test(value)) {\n        value = value.replace(pattern, rule.replacement);\n      }\n    } catch (e) {\n      // Skip invalid patterns\n    }\n  }\n  \n  return value;\n}\n\n// Normalize extracted entities\nfor (const entity of entities) {\n  if (entity.brand) {\n    entity.brand = normalize(entity.brand, 'brand');\n  }\n  if (entity.owner && entity.owner.label) {\n    entity.owner.label = normalize(entity.owner.label, 'owner');\n  }\n}\n\n// Group by level and domain for routing\nconst grouped = {\n  global: [],\n  domain: {},\n  vertical: {}\n};\n\nconst ctMap = {};\nfor (const ct of buildData.context_types) {\n  ctMap[ct.code] = ct;\n}\n\nfor (const entity of entities) {\n  const ct = ctMap[entity.type];\n  if (!ct) {\n    grouped.global.push(entity); // Unknown types go to global\n    continue;\n  }\n  \n  if (ct.level === 'global') {\n    grouped.global.push(entity);\n  } else if (ct.level === 'domain') {\n    const domain = ct.domain_code || 'unknown';\n    if (!grouped.domain[domain]) grouped.domain[domain] = [];\n    grouped.domain[domain].push(entity);\n  } else if (ct.level === 'vertical') {\n    const vertical = ct.vertical_code || 'unknown';\n    if (!grouped.vertical[vertical]) grouped.vertical[vertical] = [];\n    grouped.vertical[vertical].push(entity);\n  }\n}\n\nreturn {\n  entities: entities,\n  grouped: grouped,\n  raw_response: rawContent,\n  message: buildData.message,\n  tenant_id: buildData.tenant_id,\n  dialog_id: buildData.dialog_id,\n  trace_id: buildData.trace_id,\n  model: response.model,\n  tokens_used: response.usage?.total_tokens,\n  _debug: buildData._debug\n};"
      },
      "id": "parse-normalize",
      "name": "Parse & Normalize",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [928, 100]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}",
        "options": {}
      },
      "id": "respond",
      "name": "Respond to Webhook",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [1152, 100]
    }
  ],
  "connections": {
    "Webhook": {
      "main": [
        [
          {
            "node": "Validate Input",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate Input": {
      "main": [
        [
          {
            "node": "Load Global Context Types",
            "type": "main",
            "index": 0
          },
          {
            "node": "Load Domain Context Types",
            "type": "main",
            "index": 0
          },
          {
            "node": "Load Vertical Context Types",
            "type": "main",
            "index": 0
          },
          {
            "node": "Load Tenant Overrides",
            "type": "main",
            "index": 0
          },
          {
            "node": "Load Normalization Rules",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Load Global Context Types": {
      "main": [
        [
          {
            "node": "Merge All Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Load Domain Context Types": {
      "main": [
        [
          {
            "node": "Merge All Data",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Load Vertical Context Types": {
      "main": [
        [
          {
            "node": "Merge All Data",
            "type": "main",
            "index": 2
          }
        ]
      ]
    },
    "Load Tenant Overrides": {
      "main": [
        [
          {
            "node": "Merge All Data",
            "type": "main",
            "index": 3
          }
        ]
      ]
    },
    "Load Normalization Rules": {
      "main": [
        [
          {
            "node": "Merge All Data",
            "type": "main",
            "index": 4
          }
        ]
      ]
    },
    "Merge All Data": {
      "main": [
        [
          {
            "node": "Build Unified Prompt",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Unified Prompt": {
      "main": [
        [
          {
            "node": "Call OpenRouter",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Call OpenRouter": {
      "main": [
        [
          {
            "node": "Parse & Normalize",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse & Normalize": {
      "main": [
        [
          {
            "node": "Respond to Webhook",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  },
  "tags": [
    {
      "id": "8dihLRJvdhkW2kZ1",
      "name": "AI"
    },
    {
      "id": "tMSCjbvPU3xrNUqz",
      "name": "ELO"
    }
  ]
}
